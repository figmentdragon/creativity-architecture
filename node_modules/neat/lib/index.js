"use strict";
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const child_process_1 = require("child_process");
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const fs_extra_1 = require("fs-extra");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const LocalFolder_1 = require("./lib/LocalFolder");
const NeatConfig_1 = require("./lib/NeatConfig");
const NeatConfigTypes_1 = require("./lib/NeatConfigTypes");
const RemoteRepo_1 = require("./lib/RemoteRepo");
let Neat = /** @class */ (() => {
    class Neat extends command_1.Command {
        async run() {
            const { args, flags } = this.parse(Neat);
            if (flags.debug === true)
                process.env["NEAT_DEBUG"] = "true";
            if (!args.repository)
                return this._help();
            else if (args.repository === "inspect")
                return this.inspect(args.folder);
            if (args.folder) {
                if (!fs_extra_1.existsSync(args.folder))
                    fs_extra_1.mkdirSync(args.folder);
                process.chdir(args.folder);
            }
            // Get path if input was a neat repo
            const repository = args.repository.includes("/")
                ? args.repository
                : await RemoteRepo_1.RemoteRepo.getNeatRepoPath(args.repository).catch(this.error);
            // Show initialization message
            this.log(chalk_1.default.cyan(`Using https://github.com/${repository}`));
            // Initialize remote repository
            const remote = new RemoteRepo_1.RemoteRepo(repository);
            const tree = await remote.getTree().catch(this.error);
            // Initialize local folder
            const local = new LocalFolder_1.LocalFolder(flags.force ? true : flags["force-download"], flags.force ? true : flags["force-inject"], flags.only, flags.except);
            // Get config
            const neatConfig = await remote.getConfig().catch(this.error);
            // Preview changes and ask for confirmation
            if (flags.silent !== true)
                await this.dryRun(tree, neatConfig, local).catch(this.error);
            // Run pre-run commands
            if (neatConfig.hasPreRun()) {
                this.log("Execute pre-run commands...");
                for (const command of neatConfig.preRun) {
                    await this.execCommand(command);
                }
            }
            // Ask questions
            if (neatConfig.hasQuestions()) {
                if (flags.silent === true) {
                    neatConfig.addReplacementsFromAnswers(neatConfig.getAnswersFromEnv(process.env));
                }
                else
                    await inquirer_1.default
                        .prompt(neatConfig.getQuestions())
                        .then((answers) => {
                        neatConfig.addReplacementsFromAnswers(answers);
                        neatConfig
                            .getEnvFromAnswers(answers)
                            .forEach((env) => (process.env[env.name] = env.value));
                    })
                        .catch(this.error);
            }
            // Run pre-download commands
            if (neatConfig.hasPreDownload()) {
                this.log("Execute pre-download commands...");
                for (const command of neatConfig.preDownload) {
                    await this.execCommand(command);
                }
            }
            // Download files
            const [addedFiles, skippedFiles, addedDirs, skippedDirs,] = await local.downloadTree(tree, neatConfig.ignore).catch(this.error);
            // Log added files to console
            this.log(`${chalk_1.default.green("✔️")} ${addedFiles.length} file(s) added:`);
            if (addedFiles.length)
                this.log(chalk_1.default.grey(addedFiles.join("\n")));
            // Log skipped files to console
            if (skippedFiles.length) {
                this.log(`${chalk_1.default.red("x")} ${skippedFiles.length} file(s) skipped:`);
                this.log(chalk_1.default.grey(skippedFiles.join("\n")));
            }
            // Replace files
            if (neatConfig.hasReplace())
                await local
                    .replaceFiles(addedFiles, neatConfig.replacements, neatConfig.replaceFilter)
                    .catch(this.error);
            // Inject files
            let addedChunks = [];
            let skippedChunks = [];
            if (neatConfig.hasChunks()) {
                const injections = await local
                    .injectChunks(neatConfig.chunks, false, addedFiles, neatConfig.replacements, neatConfig.replaceFilter)
                    .catch(this.error);
                addedChunks = injections.addedChunks;
                skippedChunks = injections.skippedChunks;
                // Log added chunks to console
                this.log(`${chalk_1.default.green("✔️")} ${addedChunks.length} chunk(s) injected:`);
                if (addedChunks.length)
                    this.log(chalk_1.default.grey(addedChunks.map(local.chunkToString).sort().join("\n")));
                // Log skipped chunks to console
                if (skippedChunks.length) {
                    this.log(`${chalk_1.default.red("x")} ${skippedChunks.length} chunk(s) skipped:`);
                    this.log(chalk_1.default.grey(skippedChunks.map(local.chunkToString).sort().join("\n")));
                }
            }
            // Run post-run commands
            if (neatConfig.hasPostRun()) {
                local
                    .getEnvVars(addedFiles, skippedFiles, addedDirs, skippedDirs, addedChunks, skippedChunks)
                    .forEach((env) => (process.env[env.name] = env.value));
                this.log("Execute post-run commands...");
                for (const command of neatConfig.postRun) {
                    await this.execCommand(command);
                }
            }
            this.log(chalk_1.default.green("\n\nYour repo is ready!"));
        }
        async inspect(repo) {
            let repository;
            let config;
            if (repo === undefined)
                this.error("You need to specify a repo to inspect");
            // If inspecting a local config file
            else if (/^\./i.test(repo)) {
                const path = repo.replace(/\/$/, "") + "/";
                if (!fs_extra_1.existsSync(`${path}/.neat.yml`))
                    this.error(`Cannot find a config file at ${path}.neat.yml`);
                else {
                    // Show initialization message
                    this.log(chalk_1.default.cyan(`Inspecting ${path}.neat.yml`));
                    // Get config
                    config = new NeatConfig_1.NeatConfig(fs_extra_1.readFileSync(`${path}.neat.yml`, "utf-8"), path);
                }
            }
            // If inspecting a remote repo
            else {
                repository = repo.includes("/")
                    ? repo
                    : await RemoteRepo_1.RemoteRepo.getNeatRepoPath(repo).catch(this.error);
                // Show initialization message
                this.log(chalk_1.default.cyan(`Inspecting https://github.com/${repository}`));
                // Initialize remote repository
                const remote = new RemoteRepo_1.RemoteRepo(repository);
                // Get config
                config = await remote.getConfig();
            }
            if (config.preRun || config.preDownload || config.postRun) {
                const stages = {
                    "pre-run": config.preRun,
                    "pre-download": config.preDownload,
                    "post-run": config.postRun,
                };
                Object.keys(stages).forEach((key) => {
                    if (stages[key].length) {
                        this.log(chalk_1.default.inverse(`\n${key}\n`));
                        stages[key].map((v) => NeatConfigTypes_1.isScriptCommandType(v)
                            ? this.log(`  - script: ${chalk_1.default.yellow(/\n/.test(v.toString())
                                ? v.toString().replace(/^|\n/g, `\n    `)
                                : v.toString())}`)
                            : this.log(`  - ${chalk_1.default.red(v.replace(/\n/g, "\n    "))}`));
                    }
                });
            }
            if (config.symLink.length) {
                this.log(`\n${chalk_1.default.inverse("symlink")}`);
                config.symLink.forEach((s) => this.log(`\n  - ${chalk_1.default.green(s.target)}: ${chalk_1.default.greenBright(s.source)}`));
            }
            if (config.ignore.length)
                this.log(`\n${chalk_1.default.inverse("ignore")} [${chalk_1.default.green(config.ignore.join(", "))}]`);
            if (config.questions.length) {
                this.log(`\n${chalk_1.default.inverse("ask")}`);
                config.questions.forEach((q) => {
                    this.log(`\n  - id: ${chalk_1.default.green(q.name)}`);
                    this.log(`    description: ${chalk_1.default.green(q.message)}`);
                    if (config.toReplace.includes(q.name))
                        this.log(`    replace: ${chalk_1.default.green("true")}`);
                    if (q.default)
                        this.log(`    default: ${chalk_1.default.green(q.default)}`);
                    else if (q.choices) {
                        const choices = q.choices();
                        if (choices.length > 0 && typeof choices[0] === "string")
                            this.log(`    default: [${chalk_1.default.green(choices.join(", "))}]`);
                        else if (choices.length > 0) {
                            this.log(`    default:`);
                            choices
                                .filter(NeatConfigTypes_1.isQuestionChoiceType)
                                .forEach((choice) => this.log(`      - ${chalk_1.default.green(choice.name)}: ${chalk_1.default.greenBright(choice.checked)}`));
                        }
                    }
                });
            }
            if (config.chunks.length) {
                this.log(`\n${chalk_1.default.inverse("inject")}`);
                config.chunks.forEach((chunk) => {
                    this.log(`\n  - id: ${chalk_1.default.green(chunk.id)}`);
                    this.log(`    if: [${chalk_1.default.green(chunk.if.join(", "))}]`);
                    this.log(`    wrap:`);
                    this.log(`      before: ${chalk_1.default.green(chunk.wrap.before.replace(/\n/g, "\\n"))}`);
                    this.log(`      after: ${chalk_1.default.green(chunk.wrap.after.replace(/\n/g, "\\n"))}`);
                    if (chunk.command)
                        this.log(`    command: ${chalk_1.default.red(chunk.command)}`);
                    const stringprops = ["target", "pattern", "file", "url", "before", "after"];
                    stringprops.forEach((v) => {
                        if (chunk[v])
                            this.log(`    ${v}: ${chalk_1.default.green(chunk[v])}`);
                    });
                });
            }
            if (config.replacePattern)
                this.log(`\n${chalk_1.default.inverse("replace_pattern")} ${chalk_1.default.green(config.replacePattern)}`);
            if (config.replaceFilter)
                this.log(`\n${chalk_1.default.inverse("replace_filter")} ${chalk_1.default.green(config.replaceFilter)}`);
        }
        async dryRun(tree, neatConfig, local) {
            // Get files that will be downloaded
            const [filesToAdd, filesToSkip] = await local.downloadTree(tree, neatConfig.ignore, true);
            // Get chunks that will be injected
            let chunksToAdd = [];
            let chunksUnknown = [];
            let chunksToSkip = [];
            if (neatConfig.hasChunks()) {
                const injections = await local
                    .injectChunks(neatConfig.chunks, true, filesToAdd)
                    .catch(this.error);
                chunksToAdd = injections.addedChunks;
                chunksUnknown = injections.unknownChunks;
                chunksToSkip = injections.skippedChunks;
            }
            // If nothing to do, skip any user input
            if (!neatConfig.preRun.length &&
                !filesToAdd.length &&
                !chunksToAdd.length &&
                !chunksUnknown.length &&
                !neatConfig.postRun.length) {
                return false;
            }
            else {
                // Preview pre-run commands
                if (neatConfig.hasPreRun()) {
                    this.log(chalk_1.default.yellow(`⚠️ ${chalk_1.default.bold(neatConfig.preRun.length)} command(s) will be run before processing:`));
                    neatConfig.preRun.map((command) => this.log(chalk_1.default.grey(command)));
                }
                // Preview pre-download commands
                if (neatConfig.hasPreDownload()) {
                    this.log(chalk_1.default.yellow(`⚠️ ${chalk_1.default.bold(neatConfig.preDownload.length)} command(s) will be run before downloading files:`));
                    neatConfig.preDownload.map((command) => this.log(chalk_1.default.grey(command)));
                }
                // Preview post-run commands
                if (neatConfig.hasPostRun()) {
                    this.log(chalk_1.default.yellow(`⚠️ ${chalk_1.default.bold(neatConfig.postRun.length)} command(s) will be run after processing:`));
                    neatConfig.postRun.map((command) => this.log(chalk_1.default.grey(command)));
                }
                // Preview files to add
                this.log(`${chalk_1.default.bold(filesToAdd.length)} file(s) will be added:`);
                if (filesToAdd.length)
                    this.log(chalk_1.default.grey(filesToAdd.join("\n")));
                // Preview files to skip
                if (filesToSkip.length) {
                    this.log(`${chalk_1.default.bold(filesToSkip.length)} file(s) will be skipped (use ${chalk_1.default.blue("--force-download")} to force):`);
                    this.log(chalk_1.default.grey(filesToSkip.join("\n")));
                }
                if (neatConfig.hasChunks()) {
                    // Preview chunks with commands
                    if (chunksUnknown.length) {
                        this.log(chalk_1.default.yellow(`⚠️ ${chalk_1.default.bold(chunksUnknown.length)} chunk(s) will be known after apply:`));
                        this.log(chalk_1.default.grey(chunksUnknown.map(local.chunkToString).sort().join("\n")));
                    }
                    // Preview chunks to add
                    this.log(`${chalk_1.default.bold(chunksToAdd.length)} chunk(s) will be injected:`);
                    if (chunksToAdd.length)
                        this.log(chalk_1.default.grey(chunksToAdd.map(local.chunkToString).sort().join("\n")));
                    // Preview chunks to skip
                    if (chunksToSkip.length) {
                        this.log(`${chalk_1.default.bold(chunksToSkip.length)} chunk(s) will be skipped (use ${chalk_1.default.blue("--force-inject")} to force):`);
                        this.log(chalk_1.default.grey(chunksToSkip.map(local.chunkToString).sort().join("\n")));
                    }
                }
                // Ask for confirmation to proceed
                await cli_ux_1.default.anykey();
            }
            return true;
        }
        // Function to execute pre/post/pre-download run commands
        async execCommand(command) {
            // If Javascript
            if (NeatConfigTypes_1.isScriptCommandType(command)) {
                cli_ux_1.default.action.start(`Running script command`);
                const evalOutput = eval(`var fs = require('fs');\n ${command.script}`);
                this.log(evalOutput);
                cli_ux_1.default.action.stop(chalk_1.default.green("✔️ done"));
            }
            // Other commands
            else if (NeatConfigTypes_1.isString(command)) {
                return new Promise(async (resolve) => {
                    cli_ux_1.default.action.start(`Running ${chalk_1.default.grey(command)}`);
                    const output = child_process_1.exec(command, { env: process.env }, resolve);
                    if (output != null) {
                        if (output.stdout != null)
                            output.stdout.on("data", this.log);
                        if (output.stderr != null)
                            output.stderr.on("data", (d) => this.log(chalk_1.default.red(d)));
                        output.on("close", () => cli_ux_1.default.action.stop(chalk_1.default.green("✔️ done")));
                    }
                });
            }
        }
    }
    Neat.description = "Download files from a remote GitHub repo to a local folder and eventually ask questions and run pre-defined commands.";
    Neat.flags = {
        version: command_1.flags.version({ char: "v" }),
        help: command_1.flags.help({ char: "h" }),
        only: command_1.flags.string({
            char: "o",
            description: `Only download remote file names matching the passed regex.`,
            exclusive: ["except"],
        }),
        except: command_1.flags.string({
            char: "e",
            description: `Any remote file name matching the passed regex will not be downloaded.`,
            exclusive: ["only"],
        }),
        "force-inject": command_1.flags.boolean({
            description: `Force replacing injections that already exist.`,
            exclusive: ["force"],
        }),
        "force-download": command_1.flags.boolean({
            description: `Force downloading and replacing files that already exist.`,
            exclusive: ["force"],
        }),
        force: command_1.flags.boolean({
            char: "f",
            description: `Force downloads and injections (same as combining --force-inject and --force-download)`,
            exclusive: ["force-inject", "force-download"],
        }),
        silent: command_1.flags.boolean({
            char: "s",
            description: `Don't ask for any user input.`,
        }),
        debug: command_1.flags.boolean({
            char: "d",
            description: `Used to help identify what went wrong when creating Neat config files`,
        }),
    };
    Neat.args = [
        {
            name: "repository",
            description: `Repo to use as a template.
Use a name from the official neat-repos.yml file or a GitHub path like owner/repo
Also supports tags and branches such as neat-repo@v1 or owner/repo@master`,
        },
        {
            name: "folder",
            description: "Target folder. If it doesn't exist, it will be created.",
        },
    ];
    return Neat;
})();
module.exports = Neat;
