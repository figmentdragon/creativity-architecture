"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteRepo = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const debug_1 = require("./debug");
const NeatConfig_1 = require("./NeatConfig");
let RemoteRepo = /** @class */ (() => {
    class RemoteRepo {
        constructor(repository) {
            this.api_endpoint = "https://api.github.com";
            this.raw_endpoint = "https://raw.githubusercontent.com";
            this.config = null;
            this.tree = [];
            // https://regexr.com/54m91
            const urlParts = repository.match(/^\/?(([^/]+)\/([^/@]+))\/?(@(.+))?$/i);
            const repo = urlParts && urlParts[1];
            if (!repo)
                throw "There is an error in your repo name";
            this.repository = repo;
            this.branch = (urlParts && urlParts[5]) || "master";
            debug_1.debug("RemoteRepo Object", this);
        }
        // Get repo uri of a neat repo
        static async getNeatRepoPath(name) {
            const repoParts = name.match(/(^[\w\d-]+)(@.*)?$/i);
            if (!repoParts || !repoParts[1])
                throw "This is no a valid repo name";
            const repoName = repoParts[1];
            const repoBranch = repoParts[2];
            return node_fetch_1.default(this.neat_repos)
                .then((res) => {
                if (res.ok)
                    return res.json();
                else
                    throw res.statusText;
            })
                .then(async (res) => {
                if (res.hasOwnProperty(repoName))
                    return repoBranch ? res[repoName] + repoBranch : res[repoName];
                else
                    throw `Cannot find this repo in the list ${this.neat_repos}`;
            });
        }
        // Get config object
        async getConfig() {
            if (this.config === null)
                this.config = await this.fetchNeatConfig();
            return this.config;
        }
        // Get remote repository tree
        async getTree() {
            return Object.keys(this.tree).length > 0
                ? this.tree
                : await this.fetchTree();
        }
        // Get neat config from remote file
        async fetchNeatConfig() {
            return node_fetch_1.default(`${this.raw_endpoint}/${this.repository}/${this.branch}/.neat.yml`)
                .then((res) => {
                if (res.ok)
                    return res.text();
                else
                    return "";
            })
                .then((config) => new NeatConfig_1.NeatConfig(config, `${this.raw_endpoint}/${this.repository}/${this.branch}/`));
        }
        // Fetch remote repository tree
        async fetchTree() {
            await this.getConfig();
            return node_fetch_1.default(`${this.api_endpoint}/repos/${this.repository}/git/trees/${this.branch}?recursive=1`)
                .then((res) => {
                if (res.ok)
                    return res.json();
                else
                    throw res.statusText;
            })
                .then((res) => {
                if (!res.tree || res.tree.length === 0)
                    throw `${this.repository}@${this.branch} is empty`;
                const ignore = [];
                let ignoreNeatYml = true;
                const tree = res.tree.map((entry) => {
                    let url = `${this.raw_endpoint}/${this.repository}/${this.branch}/${entry.path}`;
                    // Replace the url for symlinks
                    if (this.config && this.config.hasSymLink()) {
                        this.config.symLink.forEach((symlink) => {
                            if (entry.path === symlink.target) {
                                url = `${this.raw_endpoint}/${this.repository}/${this.branch}/${symlink.source}`;
                                if (symlink.target === ".neat.yml")
                                    ignoreNeatYml = false;
                            }
                        });
                    }
                    return {
                        path: entry.path,
                        type: entry.type === "tree" ? "tree" : "blob",
                        url: url,
                    };
                });
                // Add symlinks that do not exist already
                if (this.config && this.config.hasSymLink()) {
                    this.config.symLink.forEach((symlink) => {
                        ignore.push(symlink.source);
                        const matches = tree.filter((entry) => entry.path === symlink.target);
                        if (matches.length === 0) {
                            tree.push({
                                path: symlink.target,
                                type: "blob",
                                url: `${this.raw_endpoint}/${this.repository}/${this.branch}/${symlink.source}`,
                            });
                        }
                    });
                }
                if (ignoreNeatYml)
                    ignore.push(".neat.yml");
                const newTree = tree.filter((v) => !ignore.includes(v.path));
                debug_1.debug("detected repository files", newTree);
                return newTree;
            });
        }
    }
    RemoteRepo.neat_repos = "https://raw.githubusercontent.com/olivr-com/neat/master/neat-repos.json";
    return RemoteRepo;
})();
exports.RemoteRepo = RemoteRepo;
