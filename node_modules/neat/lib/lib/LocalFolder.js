"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalFolder = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const lodash_escaperegexp_1 = tslib_1.__importDefault(require("lodash.escaperegexp"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const util_1 = require("util");
const debug_1 = require("./debug");
const exec = util_1.promisify(child_process_1.exec);
class LocalFolder {
    constructor(forceDownload = false, forceInject = false, only = undefined, except = undefined, folder = "") {
        this.forceDownload = forceDownload;
        this.forceInject = forceInject;
        // https://regexr.com/54vr1
        const dir = folder.replace(/((?<!^\.|^\.\.|^)\/$|^\.$)/, "");
        // https://regexr.com/54vr7
        this.dir = dir ? (/^\.*\//.test(dir) ? dir : `./${dir}/`) : "./";
        this.only = only ? new RegExp(only, "i") : null;
        this.except = except ? new RegExp(except, "i") : null;
        debug_1.debug("LocalFolder Object", this);
    }
    getEnvVars(addedFiles, skippedFiles, addedDirs, skippedDirs, addedChunks, skippedChunks) {
        return [
            {
                name: "NEAT_ALL_FILES_DIRS",
                value: addedFiles
                    .concat(skippedFiles)
                    .concat(addedDirs)
                    .concat(skippedDirs)
                    .join(", "),
            },
            {
                name: "NEAT_ADDED_FILES_DIRS",
                value: addedFiles.concat(addedDirs).join(", "),
            },
            {
                name: "NEAT_SKIPPED_FILES_DIRS",
                value: skippedFiles.concat(skippedDirs).join(", "),
            },
            {
                name: "NEAT_ALL_FILES",
                value: addedFiles.concat(skippedFiles).join(", "),
            },
            {
                name: "NEAT_ADDED_FILES",
                value: addedFiles.join(", "),
            },
            {
                name: "NEAT_SKIPPED_FILES",
                value: skippedFiles.join(", "),
            },
            {
                name: "NEAT_ALL_DIRS",
                value: addedDirs.concat(skippedDirs).join(", "),
            },
            {
                name: "NEAT_ADDED_DIRS",
                value: addedDirs.join(", "),
            },
            {
                name: "NEAT_SKIPPED_DIRS",
                value: skippedDirs.join(", "),
            },
            {
                name: "NEAT_ALL_CHUNKS",
                value: addedChunks
                    .concat(skippedChunks)
                    .map(this.chunkToString)
                    .join(", "),
            },
            {
                name: "NEAT_ADDED_CHUNKS",
                value: addedChunks.map(this.chunkToString).sort().join(", "),
            },
            {
                name: "NEAT_SKIPPED_CHUNKS",
                value: skippedChunks.map(this.chunkToString).sort().join(", "),
            },
        ];
    }
    // Download all files from a remote repo
    async downloadTree(tree, ignore, preview = false) {
        const addedFiles = [];
        const skippedFiles = [];
        const addedDirs = [];
        const skippedDirs = [];
        // Ensure target folder exists
        if (!preview)
            fs_extra_1.ensureDirSync(this.dir);
        // Create directories
        await Promise.all(tree
            .filter((v) => this.isAllowedDir(v, ignore))
            .map((file) => {
            const path = `${this.dir}${file.path}`;
            if (!fs_extra_1.existsSync(path)) {
                if (!preview)
                    fs_extra_1.mkdirSync(path);
                addedDirs.push(path);
            }
            else
                skippedDirs.push(path);
        }));
        // Download files
        await Promise.all(tree
            .filter((v) => this.isAllowedFile(v, ignore))
            .map((file) => {
            const path = `${this.dir}${file.path}`;
            // Don't overwrite if not forcing
            if (fs_extra_1.existsSync(path) && this.forceDownload === false) {
                skippedFiles.push(path);
                Promise.resolve();
            }
            // Download files to the filesystem
            else {
                return node_fetch_1.default(file.url).then(async (res) => {
                    if (!res.ok)
                        throw `${path}: ${res.statusText}`;
                    return new Promise((resolve, reject) => {
                        if (!preview) {
                            fs_extra_1.ensureFileSync(path);
                            const dest = fs_extra_1.createWriteStream(path);
                            dest
                                .on("open", function () {
                                res.body.pipe(dest);
                            })
                                .on("finish", () => {
                                resolve(true);
                                addedFiles.push(path);
                            })
                                .on("error", reject);
                        }
                        else {
                            addedFiles.push(path);
                            resolve(true);
                        }
                    });
                });
            }
        }));
        return [
            addedFiles.sort(),
            skippedFiles.sort(),
            addedDirs.sort(),
            skippedDirs.sort(),
        ];
    }
    async injectChunks(chunks, preview = false, onlyFiles = null, replacements = {}, filter = /.*/i) {
        const canInjectFiles = onlyFiles == null ? [] : [...onlyFiles];
        const addedChunks = [];
        const skippedChunks = [];
        const unknownChunks = [];
        for (const originalChunk of chunks) {
            const chunk = Object.assign({}, originalChunk);
            chunk.target = this.dir + chunk.target;
            const source = (chunk.file || chunk.url || chunk.command);
            if (preview === true && chunk.command)
                unknownChunks.push({
                    target: chunk.target,
                    source: source,
                });
            else if (!this.forceInject &&
                fs_extra_1.existsSync(chunk.target) &&
                canInjectFiles != null &&
                !canInjectFiles.includes(chunk.target)) {
                skippedChunks.push({
                    target: chunk.target,
                    source: source,
                });
            }
            else {
                if (!fs_extra_1.existsSync(chunk.target) && canInjectFiles != null)
                    canInjectFiles.push(chunk.target);
                await this.injectChunk(chunk, preview, replacements, filter)
                    .then((injected) => {
                    if (injected === true)
                        addedChunks.push({
                            target: chunk.target,
                            source: source,
                        });
                    else
                        skippedChunks.push({
                            target: chunk.target,
                            source: source,
                        });
                })
                    .catch((err) => {
                    skippedChunks.push({
                        target: chunk.target,
                        source: source,
                        error: err,
                    });
                });
            }
        }
        return {
            addedChunks: addedChunks,
            skippedChunks: skippedChunks,
            unknownChunks: unknownChunks,
        };
    }
    async injectChunk(chunk, preview = false, replacements, filter) {
        let sourceContent = "";
        if (chunk.file) {
            if (!fs_extra_1.existsSync(this.dir + chunk.file))
                throw `${this.dir + chunk.file} does not exist`;
            sourceContent = fs_extra_1.readFileSync(this.dir + chunk.file, "utf8");
            sourceContent = this.replaceContent(sourceContent, replacements, chunk.file, filter);
        }
        else if (chunk.url) {
            sourceContent = await node_fetch_1.default(chunk.url).then((res) => res.text());
            sourceContent = this.replaceContent(sourceContent, replacements, chunk.url, filter);
        }
        else if (chunk.command) {
            const { stdout, stderr } = await exec(chunk.command);
            if (stderr)
                throw stderr;
            sourceContent = stdout;
        }
        if (!fs_extra_1.existsSync(chunk.target) && !chunk.if.includes("no-file"))
            return false;
        const escapedPattern = lodash_escaperegexp_1.default(chunk.pattern);
        const singlePatternRegex = new RegExp(escapedPattern, "i");
        const doublePatternRegex = new RegExp(`${escapedPattern}[\\s\\S]*${escapedPattern}`, "i");
        const oldTargetContent = fs_extra_1.existsSync(chunk.target)
            ? fs_extra_1.readFileSync(chunk.target, "utf8")
            : "";
        // Remove any existing match of the pattern in the content
        sourceContent = sourceContent.replace(RegExp(escapedPattern, "ig"), "");
        // Add the pattern at the begining and at the end of the content
        sourceContent = `${chunk.wrap.before}${sourceContent
            .replace(/^(\r\n|\n|\r)+/, "")
            .replace(/(\r\n|\n|\r)+$/, "")}${chunk.wrap.after}`;
        let newTargetContent = null;
        // If file was not found
        if (!fs_extra_1.existsSync(chunk.target) && chunk.if.includes("no-file")) {
            newTargetContent = sourceContent;
            if (!preview)
                fs_extra_1.ensureFileSync(chunk.target);
        }
        // If pattern was not found
        else if (!singlePatternRegex.test(oldTargetContent) &&
            !doublePatternRegex.test(oldTargetContent) &&
            chunk.if.includes("no-pattern")) {
            if (chunk.before || chunk.after) {
                // before or after a pattern
                const placementRegex = new RegExp(lodash_escaperegexp_1.default(chunk.before ? chunk.before : chunk.after), "i");
                if (placementRegex.test(oldTargetContent)) {
                    newTargetContent = oldTargetContent.replace(placementRegex, chunk.before
                        ? `${sourceContent}\n${chunk.before}`
                        : `${chunk.after}\n${sourceContent}`);
                }
            }
            // add at the end of the file if no before/after or if before/after pattern not found
            if (newTargetContent === null) {
                newTargetContent =
                    oldTargetContent
                        .replace(/^(\r\n|\n|\r)+/, "")
                        .replace(/(\r\n|\n|\r)+$/, "") +
                        (/^(\r\n|\n|\r|\s)*$/.test(oldTargetContent) ? "" : "\n\n") +
                        sourceContent;
            }
        }
        // double pattern
        else if (doublePatternRegex.test(oldTargetContent)) {
            if (chunk.if.includes("double-pattern") && this.forceInject === true)
                newTargetContent = oldTargetContent.replace(doublePatternRegex, sourceContent);
        }
        // single pattern
        else if (singlePatternRegex.test(oldTargetContent) &&
            chunk.if.includes("single-pattern")) {
            newTargetContent = oldTargetContent.replace(singlePatternRegex, sourceContent);
        }
        if (newTargetContent === null)
            return false;
        else {
            if (!preview)
                fs_extra_1.writeFileSync(chunk.target, newTargetContent);
            return true;
        }
    }
    async replaceFiles(files, replacements, filter) {
        return Promise.all(files.map(async (file) => new Promise((resolve) => {
            if (filter.test(file)) {
                const content = fs_extra_1.readFileSync(file, "utf8");
                const newContent = this.replaceContent(content, replacements);
                fs_extra_1.writeFileSync(file, newContent);
            }
            resolve();
        })));
    }
    replaceContent(content, replacements, path = "", filter = /.*/i) {
        const pattern = new RegExp(Object.keys(replacements)
            .map((v) => lodash_escaperegexp_1.default(v))
            .join("|"), "ig");
        return !filter.test(path)
            ? content
            : content.replace(pattern, function (match) {
                return replacements[match] ? replacements[match] : "";
            });
    }
    chunkToString(chunk) {
        let msg = `${chunk.target} (${chunk.source})`;
        if (chunk.error)
            msg = msg + " " + chunk.error;
        return msg;
    }
    isAllowedDir(value, ignore = []) {
        return value.type === "tree" ? this.isAllowed(value.path, ignore) : false;
    }
    isAllowedFile(value, ignore = []) {
        return value.type === "blob" ? this.isAllowed(value.path, ignore) : false;
    }
    isAllowed(path, ignore) {
        const folderRegex = new RegExp(`^(${ignore.map((v) => v.replace(/\/$/, "")).join("|")})/`, "i");
        if (ignore.length > 0 && (ignore.includes(path) || folderRegex.test(path)))
            return false;
        if (this.only)
            return this.only.test(path);
        else if (this.except)
            return !this.except.test(path);
        else
            return true;
    }
}
exports.LocalFolder = LocalFolder;
